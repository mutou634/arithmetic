package demo;
import java.util.Scanner;
class Solution {
    public static int reverse(int x) {
          long temp=0;
          while(x!=0){    //不能写while（0）这是与C语言不同的，只认Boolean型
              temp=temp*10+x%10;
              x=x/10;
          }
          return (int)temp==temp?(int)temp:0;  //判断有无溢出下方注释
    }
}
public class IntegerChange{

	public static void main(String[] args) {
        int x=0;
        System.out.println("Please input one integer:");
        Scanner receive=new Scanner(System.in);
        try{
        	x=receive.nextInt();
        }
        catch(java.util.InputMismatchException e) {
        	System.out.println("The input integer exceeds the range!");
        }
        x=Solution.reverse(x);
        System.out.println("Your answer:"+x);
        receive.close();
	}
}
//收获：整数倒转算式，静态内部类，捕捉异常
/*
 * 原码、反码、补码的相互转化作为一名计算机的学生应该都很清楚了。
 * 整数的范围是-2^31 ~ 2^31-1,也就是[-2147483648,2147483647]。
    -2147483648
二进制：1000 0000 0000 0000 0000 0000 0000 0000
    2147483647
二进制：0111 1111 1111 1111 1111 1111 1111 1111
最主要的是要搞清楚-2147483648这个数是怎么来的。
我们都知道最高位是符号位，那么-2147483647用二进制表示
就是1111 1111 1111 1111 1111 1111 1111 1111。
(-2147483647)+(-1)等于两个数的补码相加，转化成源码就是其值。
这两个数的补码值相加后为1000 0000 0000 0000 0000 0000 0000 0000。
可以发现这个值和-2147483648的二进制相同，这是为什么呢？问题先放到这里，
后面再做解释。

我们再想一下零的问题。
    正零
二进制：0000 0000 0000 0000 0000 0000 0000 0000
    负零
二进制：1000 0000 0000 0000 0000 0000 0000 0000

但是计算机里是以补码计算的，正零的补码是它本身，负零的补码是它的源码除了
符号位不变其余位全取返再加一，由于溢出以为，所以
为0000 0000 0000 0000 0000 0000 0000 0000。

负零的补码为0，和正零相同。所以没有必要区分正零和负零，但是这样就多出来一
个数：1000 0000 0000 0000 0000 0000 0000 0000，刚好这个值和之前我们分析的
(-2147483647)+(-1)的补码值相同，他们俩相加刚好等于-2147483648。所以就规
定了1000 0000 0000 0000 0000 0000 0000的值为-2147483648。
那么
(-2147483648)+(-1) = ?
2147483647+1=?
写个程序的话可以看到他们分别等于2147483647、-2147483648。可以发现两个正数相加，
若溢出，符号位改变;两个负数相加，若溢出，符号位也改变。
因此，在判断两个int值相加时，若溢出，则他们计算出的值与我们实际计算的值不符。
原因就是计算机int值数运算时若超过int数值范围会溢出。
*/
